---
layout: post
title: 2025.06.30 TIL
subtitle: 이것이 갓생
tags: [js]
---

# You Don't Know JS Yet

## 변수의 생명 주기

- const로 선언된 변수를 다시 선언하는 것은 재할당하는 것과 같음
  - const 선언은 재할당할 수 없음 -> 재선언이 허용되지 않음
  - let은 기술적으로 재선언이 가능하지만 일관성 유지를 위해 허용하지 않음
- 스코프가 반복될때 재선언이 아니라 초기화되는 것임
- TDZ(temporal dead zone): 스코프에 진입한 후, 변수 자동 초기화가 일어나기까지의 시간
- let/const도 호이스팅되지만 자동 초기화가 되지 않아 TDZ 구간이 발생

## 스코프 노출 제한

- 최소 노출의 원칙, Principle of Lease Exposure(POLE)
- 스코프마다 등록된 변수의 노출을 최소화하고 싶음
  - 이름 충돌
  - 예기치 않은 작동
  - 의도하지 않은 종속성
- 외부/전역 스코프와 내부 함수 사이에 숨길 변수가 위치할 중간 스코프를 정의
  - 매번 스코프를 정의하기 귀찮으니 즉시 실행 함수 표현식, Immediately Invoked Function Expression(IIFE)를 사용
- 중괄호 쌍이 모두 블록 스코프는 아님
  - 객체 리터럴 {}
  - class {}
  - function 본문 감쌀 때, 블록 스코프가 아닌 함수 스코프임
  - switch case의 {}는 블록이나 스코프를 정의할 수 없음
- var를 쓴 이유: 이 변수는 함수 스코프라는 시각적 구분을 위해
- catch 블록을 오류 객체 변수 선언 없이 사용하면 catch 블록은 스코프를 형성하지 않고 그냥 블록으로 처리됨
- 블록 내 함수 선언, Function declarations in Blocks (FiB)은 변덕스러우니 사용을 피해야함

## 클로저

- 함수에서만 일어나는 함수의 동작
- 내부 함수가 외부 스코프에 있는 변수를 참조하는 것
- 클로저는 변수 자체에 언제든 접근할 수 있도록 관계를 맺어주는 live link